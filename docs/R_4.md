## 4. Компиляция и исполнение РефалАБ-программ

<div id="toc"></div>
<script src="toc.js"></script>
<script>
makeTOC.localizedHeader = "Содержание"
makeTOC.localizedShow = "Показать";
makeTOC.localizedHide = "Скрыть";
</script>

### Введение

Компиляция и компоновка РефалАБ-программ может
производиться на ПК под управлением следующих операционных систем:
- Windows ([Mingw-w64](https://winlibs.com/)
(требуется UCRT Runtime Clang 18.1.8 или позже (with POSIX threads))),
- POSIX-совместимые (требуется clang 18.1.8 или позже).

Для исполнения РефалАБ-программ не требуется ни MinGW-w64, ни clang.

РефалАБ-система представляет собой совокупность следующих файлов:
- РефалАБ-компилятор,
- РефалАБ-компилятор (режим отладки),
- библиотека объектных модулей - интерпретатор из промежуточного языка -
'языка сборки',
- библиотека объектных модулей (режим отладки) - интерпретатор
из промежуточного языка - 'языка сборки',
- объектные файлы для запуска РефалАБ-программы и отладчика РефалАБ-программы,
- файл заголовков для разработчиков,
- командные файлы,
- тестовые РефалАБ-программы.

В комплект поставки исходников РефалАБ-системы входят:
- исходные тексты на языке Си,
- файлы сборки РефалАБ-системы,
- файл заголовков для разработчиков,
- командные файлы,
- тестовые РефалАБ-программы.

### 4.1. Сборка РефалАБ-системы

#### 4.1.1. Windows

Чтобы собрать РефалАБ-систему в Windows из исходников РефалАБ-системы,
требуется [Mingw-w64](https://winlibs.com/) (UCRT Runtime Clang 18.1.8 или позже (with POSIX threads)).

32-битная версия Mingw-w64 Win32 - i686 позволяет собрать 32-битную РефалАБ-систему.

64-битная версия Mingw-w64 Win64 - x86_64 позволяет собрать 64-битную РефалАБ-систему.

В процессе сборки РефалАБ-системы необходимо, чтобы папка {MinGW-w64}\bin
({MinGW-w64} - путь к папке, где находится MinGW-w64) была в переменной окружения PATH.

Распакуйте исходники РефалАБ-системы в любую директорию X. Перейдите в папку RefalAB:

    cd X\RefalAB

Запустите процесс сборки одним из  двух способов:
- Переименуйте сборочный файл для Windows Makefile.Windows в Makefile. Выполните

    mingw32-make

- Выполните

    mingw32-make --file=Makefile.Windows

Результатом сборки будут:
1. РефалАБ-компиляторы bin\RefalAB.exe и bin\RefalAB_dbg.exe (режим отладки).
2. интерпретаторы из промежуточного языка - 'языка сборки',
выделенные как множества объектных модулей в библиотеках lib\libRefalAB.a и lib\libRefalAB_dbg.a (режим отладки).
3. объектные файлы - lib\mainrf.o (для запуска РефалАБ-программы)
и lib\rfdbg.o (для запуска отладчика РефалАБ-программы).

Для проверки правильности сборки РефалАБ-системы необхоимо запустить тестовые примеры.
Запустите, находясь в X\RefalAB, скрипт RefalABclg.bat:

    RefalABclg tests\{name}

где

    {name} := hello | fact | test0..test5
 
Для работы примера "fact" (факториал n) вы должны ввести целое число n.

Введите 0 или пустую строку для выхода. 

Обратите внимание на то, что завершающие сообщения "Recognition impossible"
для примеров test1, test4 и test5 являются правильными, поскольку в этих тестах
имеются фрагменты на проверку неотождествления.

По необходимости, можно запустить тестовые примеры,
используя RefalABclg_dbg.bat для запуска в режиме отладки,
RefalABdclg.bat для запуска отладчика,
RefalABdclg_dbg.bat для запуска отладчика в режиме отладки.

#### 4.1.2. POSIX

Чтобы собрать РефалАБ-систему в POSIX-совместимой ОС
из исходников РефалАБ-системы, требуется clang 18.1.8 или позже.

32-битная версия clang позволяет собрать 32-битную РефалАБ-систему.

64-битная версия clang позволяет собрать 64-битную РефалАБ-систему.

Распакуйте исходники РефалАБ-системы в любую директорию X. Перейдите в папку RefalAB:

    cd X/RefalAB

Переименуйте сборочный файл для POSIX Makefile.POSIX в Makefile. Запустите процесс сборки:

    make

Результатом сборки будут:
1. РефалАБ-компиляторы bin/RefalAB и bin/RefalAB_dbg (режим отладки).
2. интерпретаторы из промежуточного языка - 'языка сборки',
выделенные как множества объектных модулей в библиотеках lib/libRefalAB.a и lib/libRefalAB_dbg.a (режим отладки).
3. объектные файлы - lib/mainrf.o (для запуска РефалАБ-программы)
и lib/rfdbg.o (для запуска отладчика РефалАБ-программы).

Для проверки правильности сборки РефалАБ-системы необхоимо запустить тестовые примеры.
Запустите, находясь в X/RefalAB, скрипт RefalABclg:

    ./RefalABclg tests/{name}

где

    {name} := hello | fact | test0..test5
 
Для работы примера "fact" (факториал n) вы должны ввести целое число n.

Введите 0 или пустую строку для выхода. 

Обратите внимание на то, что завершающие сообщения "Recognition impossible"
для примеров test1, test4 и test5 являются правильными, поскольку в этих тестах
имеются фрагменты на проверку неотождествления.

По необходимости, можно запустить тестовые примеры,
используя RefalABclg_dbg для запуска в режиме отладки,
RefalABdclg для запуска отладчика,
RefalABdclg_dbg для запуска отладчика в режиме отладки.

### 4.2. РефалАБ-система на ПК

#### 4.2.1. Windows

На ПК с Windows РефалАБ-система хранится в следующих файлах: 
- bin\RefalAB.exe - РефалАБ-компилятор;
- bin\RefalAB_dbg.exe - РефалАБ-компилятор (режим отладки);
- lib\libRefalAB.a - библиотека объектных модулей - интерпретатор
из промежуточного языка - 'языка сборки', которая содержит
библиотечные и интерфейсные функции, библиотечные пустые функции
и спецификаторы;
- lib\libRefalAB_dbg.a - библиотека объектных модулей (режим отладки) -
интерпретатор из промежуточного языка - 'языка сборки', которая содержит
библиотечные и интерфейсные функции, библиотечные пустые функции
и спецификаторы;
- lib\mainrf.o и lib\rfdbg.o - объектные файлы для запуска
РефалАБ-программы и отладчика РефалАБ-программы;
- include\refalab.h - файл заголовков для разработчиков;
- RefalABc.bat, RefalABclg.bat, RefalABclg_dbg.bat,
RefalABdclg.bat, RefalABdclg_dbg.bat - командные файлы для компиляции, компоновки
и запуска РефалАБ-программы или отладчика РефалАБ-программы в обычном режиме
или в режиме отладки;
- set_env.bat - командный файл для установки переменных окружения РефалАБ;
- tests\fact.ref, tests\hello.ref, tests\test0.ref, tests\test1.ref,
tests\test2.ref, tests\test3.ref, tests\test4.ref, tests\test5.ref -
тестовые РефалАБ-программы.

Для компиляции и компоновки РефалАБ-программ  необходимо, чтобы папка {MinGW-w64}\bin
({MinGW-w64} - путь к папке, где находится MinGW-w64) была в переменной окружения PATH.

32-битная РефалАБ-система создает 32-битные исполняемые файлы РефалАБ-программ с расширением exe
и требует 32-битной версии Mingw-w64 Win32 - i686.

64-битная РефалАБ-система создает 64-битные исполняемые файлы РефалАБ-программ с расширением exe
и требует 64-битной версии Mingw-w64 Win64 - x86_64.

Находясь в RefalAB, запустив скрипт RefalABc.bat, можно скомпилировать
РефалАБ-программу в GNU Assembler код. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"),
является параметром при вызове этого командного файла: 

    RefalABc имя_файла

Находясь в RefalAB, запустив скрипт RefalABclg.bat, можно скомпилировать, скомпоновать
и запустить РефалАБ-программу в обычном режиме. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    RefalABclg имя_файла

Находясь в RefalAB, запустив скрипт RefalABclg_dbg.bat, можно скомпилировать, скомпоновать
и запустить РефалАБ-программу в режиме отладки. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    RefalABclg_dbg имя_файла

Находясь в RefalAB, запустив скрипт RefalABdclg.bat, можно скомпилировать, скомпоновать
и запустить отладчик РефалАБ-программы. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    RefalABdclg имя_файла

Находясь в RefalAB, запустив скрипт RefalABdclg_dbg.bat, можно скомпилировать, скомпоновать
и запустить отладчик РефалАБ-программы в режиме отладки. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    RefalABdclg_dbg имя_файла

Необходимые изменения (например, если требуется задать другой
список опций или компоновать программу из нескольких РефалАБ-модулей) можно
внести в эти скрипты при помощи любого текстового редактора. 

Можно запустить и проверить работу тестовых примеров.
Запустите, находясь в RefalAB, скрипт RefalABclg.bat:

    RefalABclg tests\{name}

где

    {name} := hello | fact | test0..test5
 
Для работы примера "fact" (факториал n) вы должны ввести целое число n.

Введите 0 или пустую строку для выхода. 

Обратите внимание на то, что завершающие сообщения "Recognition impossible"
для примеров test1, test4 и test5 являются правильными, поскольку в этих тестах
имеются фрагменты на проверку неотождествления.

По необходимости, можно запустить тестовые примеры,
используя RefalABclg_dbg.bat для запуска в режиме отладки,
RefalABdclg.bat для запуска отладчика,
RefalABdclg_dbg.bat для запуска отладчика в режиме отладки.

Можно установить переменные окружения РефалАБ для облегчения компиляции и компоновки РефалАБ-программ.

Для этого, находясь в RefalAB, запустите скрипт set_env.bat.

После этого будут созданны следующие переменные окружения ({RefalAB} - путь к папке RefalAB):
1. %REFALABBIN%={RefalAB}\bin.
2. %REFALABLIB%={RefalAB}\lib.
3. %REFALABINCLUDE%={RefalAB}\include.
4. %REFALABCFLAGS%="-pipe -Wall -O2".

По необходимости, можно добавить папку {RefalAB}\bin в переменную окружения PATH.

#### 4.2.2. POSIX

На ПК с POSIX-совместимой ОС РефалАБ-система хранится в следующих файлах: 
- bin/RefalAB - РефалАБ-компилятор;
- bin/RefalAB_dbg - РефалАБ-компилятор (режим отладки);
- lib/libRefalAB.a - библиотека объектных модулей - интерпретатор
из промежуточного языка - 'языка сборки', которая содержит
библиотечные и интерфейсные функции, библиотечные пустые функции
и спецификаторы;
- lib/libRefalAB_dbg.a - библиотека объектных модулей (режим отладки) -
интерпретатор из промежуточного языка - 'языка сборки', которая содержит
библиотечные и интерфейсные функции, библиотечные пустые функции
и спецификаторы;
- lib/mainrf.o и lib/rfdbg.o - объектные файлы для запуска
РефалАБ-программы и отладчика РефалАБ-программы;
- include/refalab.h - файл заголовков для разработчиков;
- RefalABc, RefalABclg, RefalABclg_dbg,
RefalABdclg, RefalABdclg_dbg - командные файлы для компиляции, компоновки
и запуска РефалАБ-программы или отладчика РефалАБ-программы в обычном режиме
или в режиме отладки;
- set_env - командный файл для установки переменных окружения РефалАБ;
- tests/fact.ref, tests/hello.ref, tests/test0.ref, tests/test1.ref,
tests/test2.ref, tests/test3.ref, tests/test4.ref, tests/test5.ref -
тестовые РефалАБ-программы.

32-битная РефалАБ-система создает 32-битные исполняемые файлы РефалАБ-программ
и требует 32-битной версии clang.

64-битная РефалАБ-система создает 64-битные исполняемые файлы РефалАБ-программ
и требует 64-битной версии clang.

Находясь в RefalAB, запустив скрипт RefalABc, можно скомпилировать
РефалАБ-программу в GNU Assembler код. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"),
является параметром при вызове этого командного файла: 

    ./RefalABc имя_файла

Находясь в RefalAB, запустив скрипт RefalABclg, можно скомпилировать, скомпоновать
и запустить РефалАБ-программу в обычном режиме. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    ./RefalABclg имя_файла

Находясь в RefalAB, запустив скрипт RefalABclg_dbg, можно скомпилировать, скомпоновать
и запустить РефалАБ-программу в режиме отладки. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    ./RefalABclg_dbg имя_файла

Находясь в RefalAB, запустив скрипт RefalABdclg, можно скомпилировать, скомпоновать
и запустить отладчик РефалАБ-программы. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    ./RefalABdclg имя_файла

Находясь в RefalAB, запустив скрипт RefalABdclg_dbg, можно скомпилировать, скомпоновать
и запустить отладчик РефалАБ-программы в режиме отладки. Имя файла, содержащего РефалАБ-программу
с одним модулем (без указания расширения ".ref"), является параметром при вызове
этого командного файла: 

    ./RefalABdclg_dbg имя_файла

Необходимые изменения (например, если требуется задать другой
список опций или компоновать программу из нескольких РефалАБ-модулей) можно
внести в эти скрипты при помощи любого текстового редактора. 

Можно запустить и проверить работу тестовых примеров.
Запустите, находясь в RefalAB, скрипт RefalABclg:

    ./RefalABclg tests/{name}

где

    {name} := hello | fact | test0..test5
 
Для работы примера "fact" (факториал n) вы должны ввести целое число n.

Введите 0 или пустую строку для выхода. 

Обратите внимание на то, что завершающие сообщения "Recognition impossible"
для примеров test1, test4 и test5 являются правильными, поскольку в этих тестах
имеются фрагменты на проверку неотождествления.

По необходимости, можно запустить тестовые примеры,
используя RefalABclg_dbg для запуска в режиме отладки,
RefalABdclg для запуска отладчика,
RefalABdclg_dbg для запуска отладчика в режиме отладки.

Можно установить переменные окружения РефалАБ для облегчения компиляции и компоновки РефалАБ-программ.

Для этого, находясь в RefalAB, запустите скрипт set_env.

    source ./set_env

После этого будут созданны следующие переменные окружения ({RefalAB} - путь к папке RefalAB):
1. $REFALABBIN={RefalAB}/bin.
2. $REFALABLIB={RefalAB}/lib.
3. $REFALABINCLUDE={RefalAB}/include.
4. $REFALABCFLAGS="-pipe -Wall -O2".

Эти переменные можно использовать в текущей оболочке и во всех процессах, запускаемых из текущей оболочки.

Чтобы сделать их постоянными, необходимо добавить в файл .bashrc директории $HOME строки:

    export REFALABBIN={RefalAB}/bin
    export REFALABLIB={RefalAB}/lib
    export REFALABINCLUDE={RefalAB}/include
    export REFALABCFLAGS="-pipe -Wall -O2"

По необходимости, можно добавить папку {RefalAB}/bin в переменную окружения PATH.

### 4.3. Подготовка исходных текстов РефалАБ-программ

Любая РефалАБ-программа состоит хотя бы из одного РефалАБ-модуля,
в котором определена функция GO, которая должна быть объявлена входной точкой
данного модуля с помощью директивы ENTRY. В РефалАБ-программе могут
быть еще РефалАБ-модули.

Исходные тексты РефалАБ-программ можно подготавливать с помощью
любого редактора текстов. Тип файла (расширение у имени файла)
должен быть ref.

РефалАБ-программа состоит из одного или нескольких таких файлов.

В каждом таком файле есть один РефалАБ-модуль.

Пример. Сохранить текст в файл hello.ref:

    HELLO +
        START
        ENTRY Go
        EXTRN Print
    
    Go      = <Print 'Hello World!'>
	
        END
 
### 4.4. Компиляция РефалАБ-модулей

Компиляция РефалАБ-модулей производится РефалАБ-компилятором
и происходит в файлы на языке ассемблера GNU Assembler.

За один запуск РефалАБ-компилятора обрабатывается один файл. 
Для компиляции необходимо выдать следующую команду:

- Windows
 
    	%REFALABBIN%\RefalAB имя_файла список_опций

- POSIX

    	$REFALABBIN/RefalAB имя_файла список_опций

Возможна компиляция в режиме отладки с помощью команды:

- Windows

    	%REFALABBIN%\RefalAB_dbg имя_файла список_опций

- POSIX

    	$REFALABBIN/RefalAB_dbg имя_файла список_опций

Имя_файла (возможно с указанием пути) без указания расширения ".ref".

Список_опций либо пуст, либо имеет следующий вид:

    опция_1 опция_2 ... опция_k

где опция_i - имя опции, представляющее собой цепочку литер из двух букв,
не содержащую пробелов. Имена опций отделяются друг от друга пробелами.

Список_опций служит для установки режимов работы компилятора.
Допускаются следующие имена опций: 
- ns - запретить выдачу исходного текста РефалАБ-программы
с сообщениями компилятора (листинг). Если не задана эта опция, листинг
программы выдается в файл имя_файла.lst. 
- fn - установить режим полных имен. Если эта опция задана, то ко всем
внутренним именам модуля спереди приписывается имя модуля и вслед за ним -
литера ":". Например, если MOD - имя модуля (оно берется из директивы
"START" в РефалАБ-программе), а GO - имя некоторой функции,
то текстовое изображение имени функции GO преобразуются в MOD:GO.
Эти расширенные имена затем можно использовать для управления
прокруткой при отладочном исполнении программы с целью различить
функции с совпадающими именами в разных модулях. 
- nn - запретить вставки в код программы текста имен рефал-функций.
Это приводит к некоторому уменьшению размера модуля,
но не допускает применения средств отладки к этому модулю.

Результатом работы компилятора будет файл с именем имя_файла.s.

**Пример 1 (Windows)**

    %REFALABBIN%\RefalAB test1

Компилируется модуль из файла test1.ref. Исходный текст модуля с
диагностикой выдается в файл test1.lst. Результат работы компилятора -
файл test1.s.

**Пример 2 (Windows)**

    %REFALABBIN%\RefalAB test2 ns

Компилируется модуль из файла test2.ref. Листинг не выводится.
Результат работы компилятора - файл test2.s.

На терминал выводится протокол работы компилятора, который содержит
имя компилируемого модуля, его длину, длину файла-результата или
сообщения об ошибках, если таковые обнаруживаются в процессе компиляции,
время компиляции.

Кроме вышеупомянутых, во время работы РефалАБ-компилятора создаются
еще два временных файла в рабочей директории: sysut1.rf и sysut2.rf. В
конце работы компилятора эти файлы уничтожаются. При нехватке места на
диске в процессе компиляции могут появится диагностические сообщения об
ошибках в работе с этими файлами.

Полученные ассемблерные файлы, перед исполнением РефалАБ-программы,
необходимо скомпилировать в объектные модули с помощью GNU Assembler as:

    as -o имя_файла.o имя_файла.s

### 4.5. Компиляция модулей первичных функций

РефалАБ-программа может использовать не только библиотечные первичные функции,
но и собственные. Такие функции находятся в модулях первичных функций. Они
написаны на языке Си, поэтому имеют расширение ".c".

В начале модуля находится макропредложение

    #include "refalab.h"

"refalab.h" - это файл заголовков для разработчиков из папки include,
который содержит объявления структур, макропеременных, переменных
и функций, необходимых для написания собственных первичных функций и программ на Си.

Потом идут описания собственных первичных функций.

Для компиляции модуля первичных функций в объектный модуль необходимо выполнить команду:

- Windows

        clang %REFALABCFLAGS% -I%REFALABINCLUDE% -c имя_файла.c -o имя_файла.o

- POSIX

        clang $REFALABCFLAGS -I$REFALABINCLUDE -c имя_файла.c -o имя_файла.o

### 4.6. Исполнение РефалАБ-программ

Создание исполняемого файла РефалАБ-программы производится компоновкой
объектных модулей, полученных компиляцией РефалАБ-модулей и модулей
первичных функций, с помощью редактора связей (компоновщика) GNU ld
через запуск компилятора языка Си clang.

Для создания исполняемого файла РефалАБ-программы, который запускает РефалАБ-программу,
необходимо скомпоновать необходимые объектные модули с объектным файлом mainrf.o
и библиотекой libRefalAB.a, скомпилированными из программы и модулей на Си и РефалАБ-модулей,
причем РефалАБ-программа вызывается из mainrf.o по имени GO.
Данная компоновка производится следующей командой:

- Windows

        clang -o имя_файла.exe имя_файла1.o ... имя_файлаn.o %REFALABLIB%\mainrf.o -L%REFALABLIB% -lRefalAB

- POSIX

        clang -o имя_файла имя_файла1.o ... имя_файлаn.o $REFALABLIB/mainrf.o -L$REFALABLIB -lRefalAB

где имя_файла1 ... имя_файлаn - имена объектных модулей, полученных компиляцией
РефалАБ-модулей и модулей первичных функций.

Если вызвать исполняемый файл имя_файла, то начнет работать программа
mainrf, которая формирует начальное поле зрения вида \<GO> и запускает
РефалАБ-машину.

Допустим, что требуется запустить РефалАБ-машину, начиная с функции
JOB. Тогда в РефалАБ-программе должно быть предложение вида
 
    GO = <JOB>

Если РефалАБ-машина останавливается не по причине нормального останова,
то перед завершением работы выводится сообщение о причине останова,
количество шагов, поле зрения, копилка, время работы интерпретатора языка сборки.

Команды компиляции, компоновки и запуска можно собрать вместе:

- Windows

        %REFALABBIN%\RefalAB имя_файла1
        as -o имя_файла1.o имя_файла1.s
        .
        .
        .
        clang %REFALABCFLAGS% -I%REFALABINCLUDE% -c имя_файлаn.c -o имя_файлаn.o
        clang -o имя_файла.exe имя_файла1.o ... имя_файлаn.o %REFALABLIB%\mainrf.o -L%REFALABLIB% -lRefalAB
        имя_файла

- POSIX

        $REFALABBIN/RefalAB имя_файла1
        as -o имя_файла1.o имя_файла1.s
        .
        .
        .
        clang $REFALABCFLAGS -I$REFALABINCLUDE -c имя_файлаn.c -o имя_файлаn.o
        clang -o имя_файла имя_файла1.o ... имя_файлаn.o $REFALABLIB/mainrf.o -L$REFALABLIB -lRefalAB
        ./имя_файла

Для создания исполняемого файла РефалАБ-программы, который запускает РефалАБ-программу
в режиме отладки, необходимо при компоновке заменить библиотеку libRefalAB.a на
библиотеку libRefalAB_dbg.a:

- Windows

        clang -o имя_файла.exe имя_файла1.o ... имя_файлаn.o %REFALABLIB%\mainrf.o -L%REFALABLIB% -lRefalAB_dbg

- POSIX

        clang -o имя_файла имя_файла1.o ... имя_файлаn.o $REFALABLIB/mainrf.o -L$REFALABLIB -lRefalAB_dbg

где имя_файла1 ... имя_файлаn - имена объектных модулей, полученных компиляцией
РефалАБ-модулей и модулей первичных функций.

Отличие режима отладки от обычного режима в том, что в режиме отладки выводится отладочная информация.
И, если РефалАБ-машина останавливается по причине нормального останова, то перед завершением работы
выводится сообщение "Concretization is executed", количество шагов, поле зрения,
копилка, время работы интерпретатора языка сборки.

### 4.7. Средства отладчика

#### 4.7.1. Вызов отладчика

Для отладки РефалАБ-программы используется отладчик РефалАБ-программы.

Для создания исполняемого файла отладчика РефалАБ-программы, который запускает
отладчик РефалАБ-программы, необходимо скомпоновать необходимые объектные модули с
объектным файлом rfdbg.o и библиотекой libRefalAB.a, скомпилированными из программы
и модулей на Си и РефалАБ-модулей, причем отладчик вызывается из rfdbg.o,
а отладчик вызывает РефалАБ-программу по имени GO. Данная компоновка производится следующей командой:

- Windows

        clang -o имя_файла.exe имя_файла1.o ... имя_файлаn.o %REFALABLIB%\rfdbg.o -L%REFALABLIB% -lRefalAB

- POSIX

        clang -o имя_файла имя_файла1.o ... имя_файлаn.o $REFALABLIB/rfdbg.o -L$REFALABLIB -lRefalAB

где имя_файла1 ... имя_файлаn - имена объектных модулей, полученных компиляцией
РефалАБ-модулей и модулей первичных функций.

Для создания исполняемого файла отладчика РефалАБ-программы, который запускает
отладчик РефалАБ-программы в режиме отладки, необходимо при компоновке заменить
библиотеку libRefalAB.a на библиотеку libRefalAB_dbg.a:

- Windows

        clang -o имя_файла.exe имя_файла1.o ... имя_файлаn.o %REFALABLIB%\rfdbg.o -L%REFALABLIB% -lRefalAB_dbg

- POSIX

        clang -o имя_файла имя_файла1.o ... имя_файлаn.o $REFALABLIB/rfdbg.o -L$REFALABLIB -lRefalAB_dbg

где имя_файла1 ... имя_файлаn - имена объектных модулей, полученных компиляцией
РефалАБ-модулей и модулей первичных функций.

Отличие режима отладки от обычного режима в том, что в режиме отладки выводится отладочная информация.

После вызова исполняемого файла начинает работать программа
rfdbg. Она выдает приглашения, в ответ на которые пользователь должен
задать управляющую информацию. Затем rfdbg анализирует полученную информацию.
Если при этом обнаруживаются ошибки, работа rfdbg заканчивается.
Если же ошибок нет, начинается исполнение РефалАБ-программы.
 
Выдается 11 приглашений:

    > (function list):
    >= (function list):
    = (function list):
    != (function list):
    < (function list):
    <= (function list):
    TRAP (function list):
    STOP (step number):
    FROM (step number):
    TO (step number):
    E._= (y/n):

Управляющая информация, задаваемая в ответ на эти приглашения,
делится на две группы: 
- управление остановом, 
- управление прокруткой.

Вся она имеет один из двух форматов:
- N - номер шага,
- F1 F2 ... FK - список имен функций.

Обратите внимание, что список имен функций задается через пробел, а
не через запятую. 
 
#### 4.7.2. Управление остановом

В отладчике РефалАБ-программы имеются средства управления остановом
двух типов: STOP-условия, которые позволяют задавать останов по номеру
шага, и TRAP-условия, которые позволяют задавать останов по имени функции.

Если в ответ на приглашение:

    STOP (step number):

ввести целое число N, то работа РефалАБ-программы прекратится, как только
будет выполнено N шагов. Например, если задано

    STOP (step number): 30000

то РефалАБ-программа остановится перед началом выполнения шага 30001.
Эта возможность полезна в тех случаях, когда отлаживаемая программа
зацикливается.
 
Если в ответ на приглашение

    TRAP (function list):

ввести список имен функций

    F1 F2 ... Fn

то это будет означать, что когда ведущим станет функциональный терм вида
\<F1 Ee> или \<F2 Ee> и т.д., РефалАБ-программа остановится, не приступая к
выполнению очередного шага (здесь F1, F2 ... Fn - функции, объявленные
ловушками, а Ee - объектное выражение).

Эта возможность полезна в тех случаях, когда требуется выдать
состояние поля зрения, копилки и ящиков в момент обращения к одной
из функций-ловушек.

Если TRAP-условие задано вместе со STOP-условием, останов
произойдет как только будет удовлетворено хотя бы одно из условий. 
 
#### 4.7.3. Управление прокруткой

Выдача протокола о ходе выполнения РефалАБ-программы (прокрутка) дает
возможность получать информацию о выполнении отдельных шагов РефалАБ-машины,
а также об обращениях к указанным функциям и о результатах этих обращений.

При выдаче информации об отдельном шаге указываются:
- номер шага, 
- ведущий функциональный терм, 
- результат выполнения шага.

При выдаче информации об обращениях к заданным функциям указывается:
- номер шага, на котором произошло обращение;
- ведущий терм;
- номер шага, на котором завершилось полное вычисление обращения к
функции; 
- окончательный результат замены, т.е. то выражение, которое получается,
когда в выражении, возникшем из обращения к функции, не осталось
ни одного функционального терма.

Задание на прокрутку может быть двух видов:
- задание диапазона прокрутки;
- задание условий прокрутки.

Диапазон прокрутки задается с помощью приглашений

    FROM (step number):
    TO (step number):

в ответ на которые нужно ввести целые числа Nf и Nt.

Задание диапазона означает, что следует выдавать информацию только
о тех шагах, номера которых лежат в интервале от Nf до Nt. Выдача
информации о тех шагах, номера которых меньше Nf или больше Nt - запрещена.
В частности, если Nf>Nt, то никакая информация выдаваться не будет. 

Если Nf не задавать, но задать Nt, или хотя бы одно условие прокрутки,
то считается, что Nf=1.

Если же задание "TO" не установлено, но определено задание "FROM"
или хотя бы одно условие прокрутки, то считается, что Nt=2147483647,
т.е. практически "бесконечность".

Таким образом, если диапазон прокрутки не задан, но задано хотя бы
одно условие прокрутки, то Nf=1 и Nt=2147483647.

Если диапазон прокрутки не пуст, и не задано ни одного условия
прокрутки, то считается, что следует выдавать информацию обо всех шагах,
лежащих в этом диапазоне.

Приведем примеры заданий на прокрутку, состоящих только из указания
диапазона.

**Пример 1**

    FROM (step number): 1

Печатается информация обо всех шагах.

**Пример 2**

    FROM (step number): 1000

Печатается информация обо всех шагах, начиная с шага 1000.

**Пример 3**

    TO (step number): 5000

Печатается информация обо всех шагах, начиная с шага 1 до шага 5000
включительно.

**Пример 4**

    FROM (step number): 500
    TO (step number): 600

Печатается информация обо всех шагах, начиная с шага 500 до шага
600 включительно.

Теперь рассмотрим, как задаются условия прокрутки.

В то время как диапазон прокрутки накладывает ограничения на номера
шагов, для которых должна выдаваться информация, условия прокрутки
указывают, какую именно информацию и о каких функциях следует выдавать.

Условия прокрутки задаются в ответ на приглашения:

    > (function list):
    >= (function list):
    = (function list):
    != (function list):
    < (function list):
    <= (function list):

в виде списка функций F1 F2 ... Fn.

Список функций, в частности, может быть пустым. Под именем функции
подразумевается то имя, которое она имеет внутри того модуля, в котором
она описана, имена функций в списке функций разделяются пробелом. 

Смысл управляющей информации:
- ">" - выдавать информацию о каждом шаге, начиная с момента обращения
к заданной функции и до полного завершения ее исполнения,
включая информацию об исполнении всех функций, которые она вызывает; 
- ">=" - то же, что для ">", плюс информация о поле зрения,
сформированном в результате работы заданной функции; 
- "=" - выдавать информацию о том шаге, на котором происходит обращение
к заданной функции; 
- "!=" - не выдавать информацию о том шаге, на котором происходит
обращение к заданной функции; 
- "<" - не выдавать информацию о работе заданной функции; 
- "<=" - информацию о работе заданной функции не выдавать, но выдать
обращение к этой функции и сформированное ею поле зрения.

Каждое условие может задаваться независимо от всех других, но при
этом надо учитывать ситуации, которые возникают из-за перекрестного
обращения функций друг к другу.

Например:
 
    > (function list): FUNC1 FUNC2
    >= (function list): FUNC
    = (function list): PSI FI
    != (function list): FI EPS
    < (function list): XXX
    <= (function list): YYY

Если в приведенном примере FUNC1 вызывает XXX и YYY, то будет
выдаваться информация о работе FUNC1 и обо всех вызываемых ею функцций,
исключая XXX и YYY, причем об XXX информации не будет никакой, а для YYY
будет выдан шаг обращения к ней и сформированное ею поле зрения. 

В общем случае условия прокрутки следующим образом истолковываются
в процессе исполнения РефалАБ-программы.

Управление прокруткой может находиться в одном из трех состояний:
S1, S2 или S3. Оно может переходить из состояния S1 в состояние S2 и обратно,
а также из состояния S2 в состояние S3 и обратно. Непосредственный
переход из S1 в S3 или из S3 в S1 - невозможен.

Переходами между состояниями S1 и S2 управляют условия ">" и ">=".
Переходами между состояниями S2 и S3 управляют условия "<" и "<=".
Условия "=" и "!=" управляют выдачей информации в состоянии S2. Таким образом,
получается следующая схема переходов: 

                        =,!=
    ------   >,>=      ------   <,<=     ------
    |    |  ------>    |    |  ------>   |    |
    | S1 |             | S2 |            | S3 |
    |    |  <------    |    |  <------   |    |
    ------             ------            ------

В начале работы прокрутка находится в состоянии S1.
 
Находясь в состоянии S1, прокрутка выполняет РефалАБ-программу до тех
пор, пока не встретится обращение к функции, для которой было задано
одно из условий ">" или ">=". Тогда прокрутка переходит в состояние S2,
причем, если задано ">=", но не задано ">", то выдается обращение к этой
функции.
 
Возврат в состояние S1 происходит только после того, как полностью
закончится вычисление обращения к функции, по которому произошел переход
из S1 в S2. При этом, если для этой функции было задано ">=", но
не задано ">", то при возврате в S1 выдается окончательный результат замены,
т.е. то выражение, которое возникло в результате полного вычисления
обращения к функции.
 
Находясь в состоянии S2, прокрутка выполняет РефалАБ-программу до тех
пор, пока не встретится обращение к функции, для которой было задано
условие "<" или "<=". Тогда прокрутка переходит в состояние S3, причем,
если задано "<=", то выдается обращение к этой функции.

Возврат в состояние S2 из состояния S3 происходит только после того,
как полностью закончится вычисление обращения к функции, по которому
произошел переход в S3 из S2. При этом, если для этой функции было
задано "<=", но не задано "<", то при возврате в S2 выдается окончательный
результат замены, т.е. то выражение, которое возникло в результате
полного вычисления обращения к функции.

Если прокрутка находится в состоянии S2, и для текущей функции не
задано ни "<", ни "<=", то прокрутка выполняет один шаг и остается в
состоянии S2. При этом, если для текущей функции задано условие "=", то
выдается обращение к функции и результат непосредственной замены
(результат выполнения шага).

Например, если заданы условия

    >= X
    = Y1 Y2 Y3
    <= Z1 Z2

то выдача будет начинаться при каждом обращении к функции X.
Будет выдаваться обращение к X и результат ее полного вычисления.
В процессе вычисления X будут выдаваться обращения к Y1, Y2, Y3
и непосредственно результаты замены, а также обращения к Z1 и Z2
и результат полного вычисления этих обращений.

Иногда требуется, чтобы выдавались только обращения к указанным
функциям и окончательные результаты замены. Этого можно добиться, задав
для них условия "=" и "<=".

Если задать только условие "<=", то будет выдаваться информация о
всей программе, а о заданных функциях - только обращение к ним 
и результат их работы.
 
И, наконец, в тех случаях, когда требуется запустить прокрутку по
всем функциям, с первого шага до последнего, можно задать условие "!="
для несуществующей функции. 
 
#### 4.7.4. Перехват останова по неотождествлению

Легкость отладки РефалАБ-программ в значительной степени обусловлена
тем, что различные нарушения в структуре обрабатываемых объектов, как
правило, довольно быстро приводят к авосту "Отождествление невозможно".
Однако это приятное свойство утрачивается, если какие-либо функции,
написанные на Си, не проверяют правильность аргумента. Поэтому при отладке
функций, написанных на Си, необходимо тщательно тестировать как те случаи,
когда обращение к функции имеет допустимый вид, так и те случаи,
когда аргумент функции задан неверно. Всегда, когда аргумент не принадлежит
к области определения функции, эта функция должна вырабатывать
авост "Отождествление невозможно". 

Таким образом, всякий тест, предназначенный для проверки функций,
написанных на Си, должен включать как правильные, так и заведомо
неправильные обращения к этим функциям.
 
Для прогона таких тестов предусмотрен особый режим "E._=". Если
РефалАБ-программа исполняется в этом режиме, то при возникновении состояния
"Отождествление невозможно" выполнение РефалАБ-программы не прекращается.
Вместо этого выдается номер текущего шага, предупреждающее сообщение
и ведущий функциональный терм. Затем ведущий терм заменяется на
пустое выражение, и работа РефалАБ-программы продолжается.
 
Таким образом, РефалАБ-программа исполняется так, словно в конце
каждой функции добавлено предложение
 
    E._ =

Этому обстоятельству режим "E._=" и обязан своим названием.

Для того, чтобы РефалАБ-программа исполнялась в режиме "E._=",
необходимо в ответ на приглашение
 
    E._= (y/n):

ответить "y".
